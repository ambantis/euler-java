package net.euler;

import java.math.BigInteger;

/**
 * Highly divisible triangular number
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * We can see that 28: 1, 2, 4, 7, 14, 28 is the first triangle number to have
 * over five divisors. What is the value of the first triangle number to have
 * over five hundred divisors?
 *
 * User: Alexandros Bantis
 * Date: 3/4/13
 * Time: 5:09 PM
 */
public class Problem012 {

  public Problem012() {}

  public long getNaturalNumberWith(int divisors) {
    long triangleNumber = 0;
    for (long i = 1; divisors > calcDivisors(triangleNumber); i++) {
      triangleNumber += i;
    }
    return triangleNumber;
  }

  private int calcDivisors(long n) {
    int divisors = 0;
    long root = roughRoot(n);
    for (long i = 1; i < root; i++) {
      if (n % i == 0)
        divisors += 2;
    }
    if (root * root == n)
      divisors++;
    return divisors;
  }

  private long roughRoot(long n) {
    long i = 1;
    while (n > i * i)
      i++;
    return i;
  }

//  The BigInteger version runs at 10,006 milliseconds versus 567 milliseconds for long version
//  public BigInteger getNaturalNumberWith(int divisors) {
//    BigInteger triangleNumber = BigInteger.ZERO;
//    for (BigInteger i = BigInteger.ONE; divisors > calcDivisors(triangleNumber); i = i.add(BigInteger.ONE))
//      triangleNumber = triangleNumber.add(i);
//    return triangleNumber;
//  }
//
//  private int calcDivisors(BigInteger n) {
//    int divisors = 0;
//    BigInteger root = roughRoot(n);
//    for (BigInteger i = BigInteger.ONE; i.compareTo(root) < 0; i = i.add(BigInteger.ONE)) {
//      if (n.mod(i).equals(BigInteger.ZERO))
//        divisors += 2;
//    }
//    if (n.equals(square(root)))
//      divisors++;
//    return divisors;
//  }
//
//  private BigInteger square(BigInteger base) {
//    return base.multiply(base);
//  }
//
//  private BigInteger roughRoot(BigInteger n) {
//    BigInteger i = BigInteger.ONE;
//    while (n.compareTo(i.pow(2)) > 0)
//      i = i.add(BigInteger.ONE);
//    return i;
//  }

}
